/**
 * BSClient
 * 
 * The blind storm client containing all the code that is common to both types
 * of clients
 * 
 * Version 0.1
 * 
 * @author opaiva
 * */
package br.usp.larc.blindstorm;

import br.usp.larc.blindstorm.exception.BSException;
import br.usp.larc.blindstorm.exception.BSInvalidMessageException;
import br.usp.larc.bnpairings.BNPoint;
import br.usp.larc.pseudojava.BigInteger;

abstract class BSClient extends BSEntity {

	//An enum to help controlling the client states
	protected enum BSCLientState {
		INITIAL,
		AWAITING_SIGN,
		READY
	};
	protected BSCLientState clientState;

	//A client state-dependent variable holder, just to avoid pointers pointing 
	//permanently to nowhere
	protected class StateVariableHolder{}
	protected final class AwaitingSignVariablesHolder
	extends StateVariableHolder {
		BigInteger alpha;
		BigInteger h_A;
		BNPoint V_A;
	}
	protected final class ReadyVariablesHolder
	extends StateVariableHolder {
		BNPoint V_A;	//Client credential
		BigInteger s_A;	//Client secret key
		BNPoint Y_A;	//Client public key
	}
	protected StateVariableHolder varHolder;

	protected BSClient() {}

	/**
	 * The constructor for the occasion when you don't have a private yet
	 * 
	 * @param securityLevel			The security level used by this client
	 * @param boothPK				The booth public key
	 * @throws BSException 
	 * */
	public BSClient(BSSecurityLevel securityLevel, byte[] boothPK)
			throws BSException {
		super(securityLevel);
		
		if (boothPK == null)
			throw new BSException("Invalid parameters!");

		this.Y = new BNPoint(E, boothPK);

		this.clientState = BSCLientState.INITIAL;
	}

	/**
	 * If the private key and credential are already calculated, this method
	 * is used to initialize the client.
	 *  
	 * @param clientCretential		The client already known credential
	 * @param clientSK				The client already known private key
	 * @throws BSException 
	 * */
	public void setSKAndCredential(byte[] clientSK, byte[] clientCredential)
			throws BSException {
		if (clientCredential == null || clientSK == null)
			throw new BSException("Invalid parameters!");

		if (clientState != BSCLientState.INITIAL)
			throw new BSException("Client at invalid state!");

		//Calculating the new parameters
		BNPoint V_A =  new BNPoint(E, clientCredential);
		BigInteger s_A = new BigInteger(clientSK).mod(N);
		BNPoint Y_A = G.multiply(s_A);
		BigInteger h_A = getHash(V_A);

		//Verifying the key validity
		if (!V_A.equals(G.multiply(s_A).add(Y.multiply(h_A))))
			throw new BSException("Invalid key!");
		
		//Saving state variables
		ReadyVariablesHolder varHolder = new ReadyVariablesHolder();
		varHolder.V_A = V_A;
		varHolder.s_A = s_A;
		varHolder.Y_A = Y_A;
		this.varHolder = varHolder;

		//Changing state
		this.clientState = BSCLientState.READY;
	}

	/**
	 * Blinds the commit message from the booth
	 * 
	 * @param commit		The commit message generated by the booth
	 * @return the blinded commit message bytes
	 * @throws BSException 
	 * */
	public final byte[] blind(byte[] commit) throws BSException {
		if (clientState != BSCLientState.INITIAL)
			throw new BSException("Client at invalid state!");

		byte[] result = null;

		BigInteger alpha = BSUtil.randomBigInteger(
				BSSecurityLevel.securityLevelToKeyLength(securityLevel)
				);
		BigInteger beta = BSUtil.randomBigInteger(
				BSSecurityLevel.securityLevelToKeyLength(securityLevel)
				);

		BNPoint VLinha_A = new BNPoint(E, commit);
		BNPoint V_A = VLinha_A.add(G.multiply(alpha).add(Y.multiply(beta)));
		BigInteger h_A = getHash(V_A);
		BigInteger hLinhaA = h_A.subtract(beta).mod(N);

		AwaitingSignVariablesHolder varHolder =
				new AwaitingSignVariablesHolder();
		varHolder.alpha = alpha;
		varHolder.h_A = h_A;
		varHolder.V_A = V_A;
		this.varHolder = varHolder;

		this.clientState = BSCLientState.AWAITING_SIGN;

		result = hLinhaA.toByteArray();

		return result;
	}

	/**
	 * Unblinds the message signed by the booth, therefore generating the 
	 * private and public key
	 * 
	 * @param sign		The message signed by the booth
	 * @throws BSException 
	 * */
	public final void unblind(byte[] sign) throws BSException {
		if (clientState != BSCLientState.AWAITING_SIGN)
			throw new BSException("Client at invalid state!");

		BigInteger alpha = ((AwaitingSignVariablesHolder) this.varHolder).alpha;
		BigInteger h_A = ((AwaitingSignVariablesHolder) this.varHolder).h_A;
		BNPoint V_A = ((AwaitingSignVariablesHolder) this.varHolder).V_A;

		BigInteger _sLinha_A = new BigInteger(sign);
		BigInteger s_A = _sLinha_A.add(alpha).mod(N);
		BNPoint Y_A = G.multiply(s_A);
		
		if (!V_A.equals(G.multiply(s_A).add(Y.multiply(h_A))))
			throw new BSException("Invalid key!");

		ReadyVariablesHolder varHolder = new ReadyVariablesHolder();
		varHolder.V_A = V_A;
		varHolder.s_A = s_A;
		varHolder.Y_A = Y_A;
		this.varHolder = varHolder;

		this.clientState = BSCLientState.READY;
	}

	/**
	 * Calculates a client anonymous public key, given its anonymous credential
	 * 
	 * @param receiverCredential		The receiver credential
	 * @return the calculated public key
	 * @throws BSException 
	 * */
	public final byte[] extractAnonymousPK(byte[] receiverCredential) 
			throws BSException {
		if (clientState != BSCLientState.READY)
			throw new BSException("Client not ready!");

		byte[] result = null;

		BNPoint V_Receiver = new BNPoint(E, receiverCredential);

		BNPoint Y_Receiver = V_Receiver.subtract(
				Y.multiply(BSUtil.h0(V_Receiver, N))
				);

		result = Y_Receiver.toByteArray(BNPoint.COMPRESSED);

		return result;
	}

	/**
	 * Calculates a client identified public key, given its identified 
	 * credential
	 * 
	 * @param receiverCredential		The receiver credential
	 * @return the calculated public key
	 * @throws BSException 
	 * */
	public final byte[] extractIdentifiedPK(byte[] receiverId, 
			byte[] receiverCredential) throws BSException {
		if (clientState != BSCLientState.READY)
			throw new BSException("Client not ready!");

		byte[] result = null;

		BNPoint V_Receiver = new BNPoint(E, receiverCredential);

		BNPoint Y_Receiver = V_Receiver.subtract(
				Y.multiply(BSUtil.h1(receiverId, V_Receiver, N))
				);

		result = Y_Receiver.toByteArray(BNPoint.COMPRESSED);

		return result;
	}

	protected byte[] encrypt(byte[] message, int len, byte[] receiverPublicKey)
			throws BSException {
		if (clientState != BSCLientState.READY)
			throw new BSException("Client not ready!");

		BNPoint Y_B = new BNPoint(E, receiverPublicKey);

		BigInteger u = BSUtil.randomBigInteger(
				BSSecurityLevel.securityLevelToKeyLength(securityLevel)
				);
		BNPoint Omega = Y_B.multiply(u);
		byte[][] sigma_tal = BSUtil.k(Omega, 0);
		byte[] c = BSUtil.g(sigma_tal[0], message);
		BigInteger h = BSUtil.h2Linha(sigma_tal[1], c, N);
		BNPoint R = G.multiply(u);

		return BSUtil.serialize(
				new byte[][]{
						c,
						h.toByteArray(),
						R.toByteArray(BNPoint.COMPRESSED)});
	}

	public final byte[] decrypt(byte[] message) throws BSException {
		if (clientState != BSCLientState.READY)
			throw new BSException("Client not ready!");

		BigInteger s_A = ((ReadyVariablesHolder) varHolder).s_A;

		int k = BSSecurityLevel.securityLevelToKeyLength(securityLevel);
		
		byte secLength = (byte) ((k+7)/8);
		
		byte[][] cryptogram = BSUtil.deserialize(message);
		
		byte[] c = cryptogram[0];
		BigInteger h = new BigInteger(cryptogram[1]);
		BNPoint R = new BNPoint(E, cryptogram[2]);

		int hLen = h.toByteArray().length;
		if(hLen < secLength) {
			throw new BSException("Decrypt: h has incorrect size:"+hLen);
		}

		BNPoint Omega = R.multiply(s_A);
		byte[][] sigma_tal = BSUtil.k(Omega, 0);
		BigInteger w = BSUtil.h2Linha(sigma_tal[1], c, N);
		
		byte[] m = null;
		
		if (w.equals(h)) {
			m = BSUtil.g(sigma_tal[0], c);
		}

		return m;
	}

	/**
	 * Signcrypts a message under the receiver public key and client
	 * private key.
	 * 
	 * @param message				The plain message bytes
	 * @param messageLength			The message length, in b(y)t(e)s?
	 * @param receiverPublicKey		The receiver calculated public key
	 * @return the signcrypted message bytes
	 * */
	public final byte[] signcrypt(byte[] message, int messageLenght,
			byte[] receiverPublicKey) throws BSException {
		if (clientState != BSCLientState.READY)
			throw new BSException("Client not ready!");

		BNPoint Y_B = new BNPoint(E, receiverPublicKey);
		BNPoint Y_A = ((ReadyVariablesHolder) varHolder).Y_A;
		BigInteger s_A = ((ReadyVariablesHolder) varHolder).s_A;

		byte[] result = null;

		BigInteger u, h, z;
		BNPoint omega, r;
		byte[][] sigma_tal;

		u = BSUtil.randomBigInteger(
				BSSecurityLevel.securityLevelToKeyLength(securityLevel)
				);
		omega = Y_B.multiply(u);
		sigma_tal = BSUtil.k(omega, 0);

		r = G.multiply(u);
		h = BSUtil.h2(r, message, Y_A, Y_B, sigma_tal[1], N);
		z = u.subtract(s_A.multiply(h)).mod(N);

		byte[] c = BSUtil.g(sigma_tal[0], message);

		byte[][] cryptogram = new byte[3][];
		cryptogram[0] = c;
		cryptogram[1] = h.toByteArray();
		cryptogram[2] = z.toByteArray();

		result = BSUtil.serialize(cryptogram);

		return result;
	}

	/**
	 * Unsigncrypts and verifies signature a message under its sender public key
	 * and its receiver private key
	 * 
	 * @param message			The ciphered message bytes
	 * @param messageLength		The ciphered message length, in b(y)t(e)s?
	 * @param senderPK			The sender calculated public key
	 * @return the plain message bytes 
	 * @throws BSInvalidMessageException 
	 * */
	public final byte[] unsigncrypt(byte[] message, byte[] senderPK)
			throws BSException, BSInvalidMessageException {
		if (clientState != BSCLientState.READY)
			throw new BSException("Client not ready!");

		BNPoint Y_B = new BNPoint(E, senderPK);

		return unsigncrypt(message, Y_B)[0];
	}

	/**
	 * Unsigncrypts a message, preparing it to a non-repudiation check. The 
	 * returned bytes <b>contain the plain text message bytes</b> and some
	 * others to the non-repudiation test
	 * 
	 * @param message		The signcrypted message bytes
	 * @param senderPK		The calculated sender public key
	 * @return the bytes ready to the non-repudiation check, <b>containing the 
	 * plain text message bytes</b>
	 * @throws BSInvalidMessageException 
	 * */
	public final byte[] prepareMessageForNonRepudiationTest(byte[] message,
			byte[] senderPK) throws BSException, BSInvalidMessageException {
		if (clientState != BSCLientState.READY)
			throw new BSException("Client not ready!");

		BNPoint Y_B = new BNPoint(E, senderPK);

		byte[][] unsigncrypted = unsigncrypt(message, Y_B);

		return BSUtil.serialize(unsigncrypted);
	}
	
	/**
	 * Lower-level method to unsigncrypt a message.
	 * 
	 * @throws BSInvalidMessageException, BSException
	 * */
	private final byte[][] unsigncrypt(byte[] message, BNPoint Y_B)
			throws BSException, BSInvalidMessageException {
		BNPoint Y_A = ((ReadyVariablesHolder) varHolder).Y_A;
		BigInteger s_A = ((ReadyVariablesHolder) varHolder).s_A;
		
		byte[][] signcryptogram = BSUtil.deserialize(message);
		
		if (signcryptogram == null)
			throw new BSInvalidMessageException("BLINDSTORM: Invalid message!",
					"Malformed message");
			
		byte[] c = signcryptogram[0];
		BigInteger h = new BigInteger(signcryptogram[1]);
		BigInteger z = new BigInteger(signcryptogram[2]).mod(N);

		BNPoint r, omega;
		BigInteger w;

		r = G.multiply(z).add(Y_B.multiply(h));
		omega = r.multiply(s_A);
		byte[][] sigma_tal = BSUtil.k(omega, 0);
		byte[] m = BSUtil.g(sigma_tal[0], c);

		w = BSUtil.h2(r, m, Y_B, Y_A, sigma_tal[1], N);
		if (!w.equals(h)) {
			throw new BSInvalidMessageException("BLINDSTORM: Invalid message!", 
					new String(m));
		}

		byte[][] result = {m, h.toByteArray(), z.toByteArray(), sigma_tal[1]};
		return result;
	}
	
	/**
	 * Returns the public key from this client
	 * 
	 * @throws BSException 
	 * */
	public byte[] getPublicKey() throws BSException {
		if (clientState != BSCLientState.READY)
			throw new BSException("Client not ready!");

		BNPoint Y_A = ((ReadyVariablesHolder) varHolder).Y_A;

		return Y_A.toByteArray(BNPoint.COMPRESSED);
	}

	/**
	 * Returns the calculated private key from this client
	 * 
	 * @throws BSException 
	 * */
	public byte[] getPrivateKey() throws BSException {
		if (clientState != BSCLientState.READY)
			throw new BSException("Client not ready!");

		BigInteger s_A = ((ReadyVariablesHolder) varHolder).s_A;

		return s_A.toByteArray();
	}

	/**
	 * Returns the credential associated with this client
	 * 
	 * @throws BSException 
	 * */
	public byte[] getCredential() throws BSException {
		if (clientState != BSCLientState.READY)
			throw new BSException("Client not ready!");

		BNPoint V_A = ((ReadyVariablesHolder) varHolder).V_A;

		return V_A.toByteArray(BNPoint.COMPRESSED);
	}

	//This method should be implemented by the specific clients types
	protected abstract BigInteger getHash(BNPoint V);

}
