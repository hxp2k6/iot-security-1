/**
 * BSUtil
 * 
 * This class contains several mathematical and utility methods used across
 * the other protocol methods. It also contains the mappings between the 
 * security levels supported and the associated parameters. 
 * 
 * Version 0.1
 * 
 * @author opaiva
 * */
package br.usp.larc.blindstorm;

import br.usp.larc.bnpairings.BNPoint;
import br.usp.larc.keccak.Keccak;
import br.usp.larc.pbarreto.jaes.AES;
import br.usp.larc.pseudojava.BigInteger;
import br.usp.larc.pseudojava.SecureRandom;

class BSUtil {

	/**
	 * This method is the hash function h_0 used by improved Mao protocol.
	 *
	 * @param V             A BNPoint.
	 * @param n             The order of the group \G.
	 * @return h_0(v)
	 */
	protected static final BigInteger h0(BNPoint V, BigInteger n) {
		Keccak keccak = new Keccak();

		keccak.init(0);

		byte[] vArray = V.toByteArray(BNPoint.COMPRESSED);

		keccak.update(vArray, vArray.length*8);

		byte[] hashH0 = new byte[(n.bitLength() + 7)/8];

		keccak.getHash(null);
		keccak.squeeze(hashH0, 8*((n.bitLength() + 7)/8));

		return new BigInteger(hashH0).mod(n);
	}

	/**
	 * This method is the hash function h_1 used by improved Mao protocol.
	 *
	 * @param id            The hash of the entity's identity.
	 * @param v             A point.
	 * @param n             The order of the group \G.
	 * @return h_1(id, v)
	 */
	protected static final BigInteger h1(byte[] id, BNPoint v, BigInteger n) {
		Keccak keccak = new Keccak();

		keccak.init(0);

		byte[] vArray = v.toByteArray(BNPoint.COMPRESSED);

		keccak.update(id, id.length*8);
		keccak.update(vArray, vArray.length*8);

		byte[] hashH1 = new byte[((n.bitLength() + 7)/8)];

		keccak.getHash(null);
		keccak.squeeze(hashH1, 8*((n.bitLength() + 7)/8));

		return new BigInteger(hashH1).mod(n);
	}

	/**
	 * This method is the hash function h_1 used by STORM protocol.
	 *
	 * @param r		The parameter R generated at step 3 of signcrypt
	 * 				algorithm.
	 * @param m		A byte array of the message in plaintext.
	 * @param y_A	The sender's public general key.
	 * @param y_B	The receiver's public general key.
	 * @param tau	The tal component generated by function \k at (un)signcrypt 
	 * 				algorithms.
	 * @param n		The order of the subjacent group \G.
	 * @return h_1(R; m; Y_A; Y_B; tal)
	 */
	protected static final BigInteger h2(BNPoint r, byte[] m, BNPoint y_A,
			BNPoint y_B, byte[] tau, BigInteger n) {
		Keccak keccak = new Keccak();

		keccak.init(0);

		keccak.update(
				r.toByteArray(BNPoint.COMPRESSED),
				r.toByteArray(BNPoint.COMPRESSED).length*8
				);
		keccak.update(m, m.length*8);
		keccak.update(
				y_A.toByteArray(BNPoint.COMPRESSED),
				y_A.toByteArray(BNPoint.COMPRESSED).length*8
				);
		keccak.update(
				y_B.toByteArray(BNPoint.COMPRESSED),
				y_B.toByteArray(BNPoint.COMPRESSED).length*8
				);
		keccak.update(tau, tau.length*8);

		byte[] hashH2 = new byte[(n.bitLength() + 7)/8];

		keccak.getHash(null);
		keccak.squeeze(hashH2, 8*((n.bitLength() + 7)/8));

		return new BigInteger(hashH2).mod(n);
	}

	/**
	 * This method is the hash function h_1 used by STORM protocol.
	 *
	 * @param tau		The tal component generated by function \k at 
	 * 					(un)signcrypt algorithms.
	 * @param c			The encrypted message.
	 * @param n			The order of the subjacent group \G.
	 * @return h_1(R; m; Y_A; Y_B; tal)
	 */
	protected static final BigInteger h2Linha(byte[] tau, byte[] c,
			BigInteger n) {
		Keccak keccak = new Keccak();

		keccak.init(0);

		keccak.update(tau, tau.length*8);
		keccak.update(c, c.length*8);

		byte[] hashH2Linha = new byte[(n.bitLength() + 7)/8];

		keccak.getHash(null);
		keccak.squeeze(hashH2Linha, 8*((n.bitLength() + 7)/8));

		return new BigInteger(hashH2Linha).mod(n);
	}

	/**
	 * The symmetric encryption function which encrypts/decrypts m under the key
	 * sigma.
	 *
	 * @param sigma		The symmetric key.
	 * @param m			A byte array of the plaintext/ciphertext.
	 * @param mode		The cipher direction: "ENC"/"DEC".
	 * @return plaintext or ciphertext depending on the mode
	 */
	protected static final byte[] g(byte[] sigma, byte[] m) {
		Keccak keccak = new Keccak();

		keccak.init(0);

		keccak.update(sigma, sigma.length*8);        

		byte[] c = new byte[m.length];

		keccak.getHash(null);
		keccak.squeeze(c, 8*m.length);

		for (int i = 0; i < m.length; i++) {
			c[i] = (byte) (c[i] ^ m[i]);
		}

		return c;
	}

	/**
	 * This method is a key derivation function (KDF).
	 *
	 * @param omega         The KDF's input which is computed in (Un)Signcrypt 
	 * 						algorithms.
	 * @param bitLength     The Keccak hash function bitlength. (Default is 0).
	 * @return  {sigma, omega}
	 */
	protected static final byte[][] k(BNPoint omega, int bitLength) {
		Keccak keccak = new Keccak();

		keccak.init(bitLength);

		keccak.update(
				omega.toByteArray(BNPoint.COMPRESSED),
				omega.toByteArray(BNPoint.COMPRESSED).length*8);

		byte[][] sigma_tal = new byte[2][AES.BLOCK_SIZE];

		keccak.getHash(null);
		keccak.squeeze(sigma_tal[0], AES.BLOCK_SIZE*8);
		keccak.squeeze(sigma_tal[1], AES.BLOCK_SIZE*8);

		return sigma_tal;
	}

	/**
	 * This method generates a random BigInteger number with the specified 
	 * number of bits k.
	 *
	 * @param k		The number of bits for the random number to be generated.
	 * @return		The generated random BigInteger.
	 */
	protected static BigInteger randomBigInteger(int k) {
		//TODO: PORQUE ESSA INICIALIZA��O MALUCA???
		byte[] randSeed = new byte[32];
		(new SecureRandom()).nextBytes(randSeed);

		return new BigInteger(k, new SecureRandom(randSeed));
	}

	/**
	 * Converts a multidimensional byte array into a unidimensional byte
	 * array, adding a metadata section at the beginning of result. The number
	 * of dimensions must be less than 256, and the total size of input should
	 * be less then (2^31 - 1 - 4*n. of. dimen), with every dimension being less
	 * than 2^31. The output has the following format:
	 * 
	 * <p/>
	 * 
	 * Being: <br/>
	 * I = Number of dimensions from original array<br/>
	 * J_i = Size of ith dimension from original array, distributed in 4 bytes<br/>
	 * source[i][j] = jth element from the ith dimension in the original array 
	 * 
	 * <pre>
	 * |            I           |
	 * |           J_1          |
	 * |           J_2          |
	 * |          ....          |
	 * |           J_I          |
	 * |      source[0][0]      |
	 * |      source[0][1]      |
	 * |          ....          |
	 * |   source[0][J_1 - 1]   |
	 * |      source[1][0]      |
	 * |      source[1][1]      |
	 * |          ....          |
	 * |   source[1][J_1 - 1]   |
	 * |          ....          |
	 * |     source[I-1][0]     |
	 * |          ....          |
	 * |  source[I-1][J_I - 1]  |
	 * </pre>
	 * 
	 * @param source		The multidimensional array
	 * @return A converted unidimensional array plus metadata
	 * */
	protected static byte[] serialize(byte[][] source) {
		byte[] result = null;

		if (source != null) {
			int nOfDimensions = source.length;

			//Size of header in bytes
			int metaDataSize = 1 + nOfDimensions*4;

			//Size of data serialized
			int dataSize = 0;
			for (int i = 0; i < nOfDimensions; i++) {
				dataSize += source[i].length;
			}

			//Instantiates the result with the final dimension
			result = new byte[metaDataSize + dataSize];

			//The first byte contains the number of dimensions
			result[0] = (byte) nOfDimensions;

			//Fills the rest of the header section with the dimensions sizes
			for (int i = 0; i < nOfDimensions; i++) {
				//Distributes the size of dimension i within 4 bytes
				int dimSize = source[i].length;
				for (int j = 0; j < 4; j++) {
					result[4*i + 1 + j] = (byte) (dimSize & 0xFF);
					dimSize = dimSize >> 8;
				}
			}

			//Puts the data serialized at the end of the array
			int counter = metaDataSize;
			for (int i = 0; i < nOfDimensions; i++) {
				System.arraycopy(
						source[i],
						0,
						result,
						counter,
						source[i].length
						);

				counter += source[i].length;
			}
		}

		return result;
	}

	/**
	 * Given a unidimensional array containing a multidimensional array and the
	 * metadata section, reassembles it. The format required is the following:
	 * 
	 * <p/>
	 * 
	 * Being: <br/>
	 * I = Number of dimensions from original array <br/>
	 * J_i = Size of ith dimension from original array, 4 bytes each <br/>
	 * source[i][j] = jth element from the ith dimension in the original array 
	 * 
	 * <pre>
	 * |            I           |
	 * |           J_1          |
	 * |           J_2          |
	 * |          ....          |
	 * |           J_I          |
	 * |      source[0][0]      |
	 * |      source[0][1]      |
	 * |          ....          |
	 * |   source[0][J_1 - 1]   |
	 * |      source[1][0]      |
	 * |      source[1][1]      |
	 * |          ....          |
	 * |   source[1][J_1 - 1]   |
	 * |          ....          |
	 * |     source[I-1][0]     |
	 * |          ....          |
	 * |  source[I-1][J_I - 1]  |
	 * </pre>
	 * 
	 * @param original		The unidimensional array
	 * @return A converted multidimensional array
	 * */
	protected static byte[][] deserialize(byte[] original) {
		byte[][] result = null;

		if (original != null && original.length > 0) {
			//The header lenght is the number of dimensions (first position of
			//serialized array) times 4 plus 1
			int metaDataLength = original[0]*4 + 1;

			if (original.length >= metaDataLength) {
				int nOfDimensions = (metaDataLength - 1)/4;

				//A vector containing the sizes of all dimensions
				int[] dimensionsSizes = new int[nOfDimensions];

				//Filling the dimensions sizes vector
				int dataLength = 0;
				for (int i = 0; i < nOfDimensions; i++) {
					dimensionsSizes[i] = 0;
					for (int j = 0; j < 4; j++) {
						int dimensionByte = 
								((original[i*4 + 1 + j]&0xFF) << j*8);
						dimensionsSizes[i] += dimensionByte;
						dataLength += dimensionByte;
					}
				}

				//Checks if the total length of byte array consistent with
				//metadata
				if (original.length == dataLength + metaDataLength) {
					result = new byte[nOfDimensions][];

					//Pointer to the beginning of current dimension
					int count = metaDataLength;

					for (int i = 0; i < nOfDimensions; i++) {
						byte[] semiResult = new byte[dimensionsSizes[i]];

						System.arraycopy(
								original,
								count,
								semiResult,
								0,
								dimensionsSizes[i]
								);

						result[i] = semiResult;

						count += dimensionsSizes[i];
					}
				}
			}
		}

		return result;
	}
	
	/**
	 * This method adjust BigInteger to byte[] conversion.
	 *
	 * @param number         BigInteger to be converted. 
	 * @param securityLevel  The security level required.
	 * @return  The desired byte array of a BigInteger.
	 */
	protected static byte[] adjustBigIntegerConversion(BigInteger number, BSSecurityLevel securityLevel) {
		// Compatibility with Java BigInteger class
		int secLevelLen = ((BSSecurityLevel.securityLevelToKeyLength(securityLevel) + 7) / 8);
		
		byte[] temp = number.toByteArray();
		byte[] numberByteArray = number.toByteArray();
		int tempLen = temp.length;
		if(tempLen != secLevelLen) {
			System.out.println("size = " + tempLen);
			System.out.println("secLevelLen = " + secLevelLen);
		}
		
		while(tempLen < secLevelLen) {
			tempLen++;
			numberByteArray = new byte[tempLen];
				System.arraycopy(
						temp,
						0,
						numberByteArray,
						1,
						tempLen - 1
						);
			numberByteArray[0] = (byte)0x00;
			temp = numberByteArray;
		}
		
		return numberByteArray;
	}
}
